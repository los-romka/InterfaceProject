/**
 * Table representation by los-romka
 */
(function( $ ) {
INTERFACE_SPECIFIER = {
    "COLLECTION": "#COLLECTION#",
    "STRING" : "#STRING#",
    "INTEGER" : "#INTEGER#",
    "REAL" : "#REAL#",
    "BOOLEAN" : "#BOOLEAN#",
    "DATETIME" : "#DATETIME#",
    "BLOB" : "#BLOB#",
    "ALT" : "#ALT#",
    "COMPLEX" : "#COMPLEX#",
    "TERMINAL_VALUE" : "#TERMINAL_VALUE#",
    "UNDEFINED" : "",
    "REGULAR_EXPR" : /#[\w]*#/g
};

COLLECTION_ORIENTATION = {
    "HORIZONTAL": "HORIZONTAL",
    "VERTICAL": "VERTICAL"
};

COLLECTION_TYPE = {
    "LIST" : "LIST",
    "SET" : "SET"
};

SPECIFIER = {
    "ONE" : "~one",
    "ONEMM" : "~onemm",
    "COPY" : "~copy",
    "COPYMM" : "~copymm",
    "SET" : "~set",
    "SETMM" : "~setmm",
    "LIST" : "~list",
    "LISTMM" : "~listmm",
    "PROXY" : "~proxy",
    "ALT" : "~ALT",
    "REGULAR_EXPR" : /~[\w]*\b/g
};

TERMINAL = {
    "SORT" : {
        "STR" : "[str]",
        "INT" : "[int]",
        "REAL" : "[real]",
        "BOOL" : "[bool]",
        "DATE" : "[date]",
        "BLOB" : "[blob]",
        "REGULAR_EXPR" : /\[(str|int|real|bool|date|blob)\]/g
    },
    "VALUE" : {
        "STR" : /\["[\w\W]*"\]/g,
        "INT" : /\[-?[\d]+\]/g,
        "REAL" : /\[-?[\d]+(\.[\d]+)?\]/g,
        "BOOL" : /\[(true|false)\]/g,
        "DATE" : /\[[\d]{2}\.[\d]{2}\.[\d]{4}-[\d]{2}:[\d]{2}:[\d]{2}.[\d]{3}\]/g,
        "BLOB" : /\['[\w\W]*'\]/g,
        "REGULAR_EXPR" : /[^\[]([\S\s]*)(?=\])/g
    },
    "REGULAR_EXPR" : /\[[\w\W]*\]/g
};

TO = {
    "STR" : function( value ) { return "[\"" + value + "\"]";},
    "INT" : function( value ) { return "[" + value + "]";},
    "REAL" : function( value ) { return "[" + value + "]";},
    "BOOL" : function( value ) { return "[" + value + "]";},
    "DATE" : function( value ) {
        var year = value.substring(0, 4),
            month = value.substring(5, 7),
            day = value.substring(8, 10),
            hour = value.substring(11, 13),
            min = value.substring(14, 16),
            sec = "00",
            milisec = "000";

        return "[" + day + "." + month + "." + year + "-" + hour + ":" + min + ":" + sec + "." + milisec + "]";
    },
    "BLOB" : function( value ) { return "[\'" + value + "\']";},
    "NAME" : function( value ) { return "[" + value + "]";}
};

FROM = {
    "STR" : function( value ) { return value.substring( 2, value.length - 2 ); },
    "INT" : function( value ) { return value.substring( 1, value.length - 1 ); },
    "REAL" : function( value ) { return value.substring( 1, value.length - 1 ); },
    "BOOL" : function( value ) { return value.substring( 1, value.length - 1 ); },
    "DATE" : function( value ) {
        var year = value.substring(7, 11),
            month = value.substring(4, 6),
            day = value.substring(1, 3),
            hour = value.substring(12, 14),
            min = value.substring(15, 17);

        return year + "-" + month + "-" + day + "T" + hour + ":" + min;
    },
    "BLOB" : function( value ) { return value.substring( 2, value.length - 2 ); },
    "NAME" : function( value ) { return value.substring( 1, value.length - 1 ); }
};

DEFAULT_VALUE = {
    "[str]" : "_",
    "[int]" : "0",
    "[real]" : "0",
    "[bool]" : "0",
    "[date]" : (function(){
        var value = (new Date()).toISOString(),
            year = value.substring(0, 4),
            month = value.substring(5, 7),
            day = value.substring(8, 10),
            hour = value.substring(11, 13),
            min = value.substring(14, 16),
            sec = "00",
            milisec = "000";

        return day + "." + month + "." + year + "-" + hour + ":" + min + ":" + sec + "." + milisec;
    })(),
    "[blob]" : "0"
};

TRANSLATE_SORT = {
    "[str]" : '(cорт: Строковое)',
    "[int]" : '(cорт: Целое)',
    "[real]" : '(cорт: Вещественное)',
    "[bool]" : '(cорт: Логическое)',
    "[date]" : '(cорт: Дата и время)',
    "[blob]" : '(cорт: Бинарные данные)'
};

ACTION = {
    SHOW: 'развернуть содержимое',
    GENERATE: 'открыть генератор понятия',
    NEW: 'создать новый экземпляр данного понятия',
    CREATE: 'сохранить после генерации',
    UPDATE: 'сохранить после редактирования',
    EDIT_TITLE: 'редактировать понятие',
    DELETE_TITLE: 'удалить отношение к понятию',
    DELETE: 'удалить отношение'
};;function in_array( value, array ) {
    for ( var i = 0; i < array.length; i++ ) {
        if ( array[i] == value ) return true;
    }

    return false;
}

function intersect(a, b) {
    a.sort(); b.sort();
    var ai = 0, bi = 0;
    var result = [];

    while( ai < a.length && bi < b.length ) {
        if (a[ai] < b[bi] ) {
            ai++;
        } else if (a[ai] > b[bi] ) {
            bi++;
        } else {
            result.push(a[ai]);
            ai++;
            bi++;
        }
    }

    return result;
}

function sortArrayByMeta(leafs, leafs_meta) {
    var swapped;
    do {
        swapped = false;
        for (var i=0; i < leafs.length-1; i++) {
            if ( compare(leafs[i], leafs[i+1]) ) {
                var temp = leafs[i];
                leafs[i] = leafs[i+1];
                leafs[i+1] = temp;
                swapped = true;
            }
        }
    } while (swapped);

    return leafs;

    function compare(a, b) {
        var aIndex = leafs_meta.findIndex(function(element) {
            return element.name === a.name;
        });

        var bIndex = leafs_meta.findIndex(function(element) {
            return element.name === b.name;
        });

        return aIndex > bIndex;
    }
}

function clone( obj ) {
    if ( obj == null || typeof( obj ) != 'object' || obj instanceof $)
        return obj;

    var temp = new obj.constructor();
    for ( var key in obj ) {
        if ( obj.hasOwnProperty( key ) ) {
            temp[key] = clone( obj[key] );
        }
    }

    return temp;
}

function toUrlParams(data) {
    var result = [];
    for ( var key in data ) {
        if ( data.hasOwnProperty( key ) ) {
            result.push(key + '=' + data[key]);
        }
    }
    return result.join('&');
}

function retrieveActionsArgs($objs) {
    var arr = [];

    $objs.map(function(index, element) {
        var params = retrieveActionParams($(element));

        arr.push([element, toUrlParams(params)]);
    });

    return arr;
}

function retrieveActionParams($element) {
    var data = {};

    var paramsRaw = $element.attr('onclick')
            .match(new RegExp("'(.+)'"))[1]
            .split('&')
            .filter(function(elem) {
                return elem && !!elem.length;
            })
        ;

    $.map(paramsRaw, function(elem) {
        var arg = elem.split('=');
        data[ arg[0] ] = arg[1];
    });

    return data;
}

function initLoading($block) {
    $block.append($('<div class="overlay"></div>').hide());
    $block.append($('<div class="modal">Загрузка...</div>').hide());
}

function startLoading($block) {
    $block.find('.overlay').height( $block.height() - 10 );
    $block.find('.overlay, .modal').show();
}

function finishLoading($block) {
    $block.find('.overlay, .modal').hide();
}

var platform_action_in_process = null;
var platform_action_queue = [];

function executeNextFromQueue() {
    var args = platform_action_queue.shift();

    if (args) {
        doPlatformActions(args[0], args[1], args[2]);
    }
}

function doPlatformActions(args, $tableRepresentationNode, callback, last_data, iterationFlag) {
    if (platform_action_in_process && !iterationFlag) {
        platform_action_queue.push([args, $tableRepresentationNode, callback]);
        return;
    }

    platform_action_in_process = true;

    var current;

    $tableRepresentationNode = $tableRepresentationNode.closest('.table-representation');

    if( current = args.shift() ) {
        var a = current[0], clickParams = current[1];

        startLoading($tableRepresentationNode);

        var win = $(a).closest('div.iacpaas-window');

        if (win.length == 0) {
            win = $tableRepresentationNode.closest('div.iacpaas-window');
        }

        $.ajax({
            type: "GET",
            url: mw.util.wikiScript(),
            data:	{
                action: 'ajax',
                rs: 'wfUiOnClickFunction',
                rsargs: [win.attr('id'), '$current-tab=' + win.attr('current-tab') + '&' + clickParams]
            },
            dataType: 'html',
            success: function(result) {
                doPlatformActions(args, $tableRepresentationNode, callback, result, true);
            }
        });
    } else {
        if ( typeof(callback) === "function" ) {
            callback( last_data );
        }

        if ( last_data ) {
            var code = $tableRepresentationNode.data('node-code');

            var new_html = $( last_data )
                .find('[data-node-code="' + code + '"]')
                .closest('.iwe-concept')
                .find('>.iwe-concept-details')
                .html();

            last_data = null;

            $tableRepresentationNode
                .closest('.iwe-concept')
                .find('>.iwe-concept-details')
                .html(new_html);

            $tableRepresentationNode
                .data('table-representation')
                .refresh();
        }

        finishLoading($tableRepresentationNode);

        platform_action_in_process = false;
        executeNextFromQueue();
    }
}

function getParentIweBlock($iweBlock) {
    return $iweBlock.parent().closest('.iwe-concept');
}

function getIweInfos($iweBlock, vertex, fromParent) {
    var info_html_name = " [" + vertex.toHtmlName() + "]";

    if (fromParent) {
        $iweBlock = getParentIweBlock($iweBlock);
    }

    if (vertex.sort) {
        return $iweBlock
            .find(
            '>.iwe-concept-details' +
            '>.iwe-concept-children' +
            '>div:contains(' + info_html_name + ')')
            .contents()
            .filter(function() { return this.nodeType == 3 && this.textContent == info_html_name; })
            .closest('div');
    }

    return $iweBlock
        .find(
        '>.iwe-concept-details' +
        '>.iwe-concept-children' +
        '>div' +
        '>.iwe-editor' +
        '>div' +
        '>.iwe-concept' +
        '>.iwe-concept-header' +
        '>div:first-child:contains(' + info_html_name + ')')
        .contents()
        .filter(function() { return this.nodeType == 3 && this.textContent == info_html_name; })
        .closest('div.iwe-concept');
}

function getIweProduceFunction($iweBlock, $block, vertex, fromParent) {
    if (fromParent) {
        $iweBlock = getParentIweBlock($iweBlock);
    }

    var $produceBtn = $iweBlock
        .find(
        '>.iwe-concept-details' +
        '>.iwe-concept-generations' +
        '>div' +
        '>:contains(' + vertex.toHtmlName() + ')');

    if ($produceBtn.length === 0) {
        return function(callback) {console.log('empty for' + vertex.name )
            callback();
        }
    }

    var params = retrieveActionParams($produceBtn);

    var produceUrlParams = {
        conceptId: params.conceptId,
        metaRelationId: params.metaRelationId,
        metaConceptId: params.metaConceptId
    };

    if ( intersect(vertex.specifiers, [SPECIFIER.COPY, SPECIFIER.COPYMM]).length > 0 ) {
        produceUrlParams.action = ACTION.GENERATE;
    } else if ( vertex.sort ) {
        produceUrlParams.action = ACTION.CREATE;
        produceUrlParams.concept_value = DEFAULT_VALUE[ vertex.sort ];
        produceUrlParams.required_field = "value";
    } else {
        produceUrlParams.action = ACTION.CREATE;
        produceUrlParams.concept_name = vertex.name;
    }

    return function(callback) {
        doPlatformActions([[$produceBtn[0], toUrlParams(produceUrlParams)]], $block, callback);
    }
}

function getIweChangeFunction($iweBlock, $block, vertex) {
    var $editBtn = $iweBlock.find(
        (vertex.sort ? '' : '>.iwe-concept-header>div')
        + '>[title="' + ACTION.EDIT_TITLE + '"]'
    );

    if ($editBtn.length === 0) {
        return function(value, callback) {
            callback();
        }
    }

    var params = retrieveActionParams($editBtn);

    var updateUrlParams = {
        required_field: params.required_field,
        conceptId: params.conceptId,
        relationId: params.relationId,
        action: ACTION.UPDATE
    };

    return function(value, callback) {
        var changeParams = $.extend({
            concept_value: value
        }, updateUrlParams);

        doPlatformActions([[$editBtn[0], toUrlParams(changeParams)]], $block, callback);
    }
}

function getIweDeleteFunction($iweBlock, $block, vertex) {
    var infos = getIweInfos($iweBlock, vertex);

    return function(index, callback) {
        var $deleteBtn = infos.eq(index).find(
            (vertex.sort ? '' : '>.iwe-concept-header>div')
            + '>[title="' + ACTION.DELETE_TITLE + '"]'
        );

        if ($deleteBtn.length === 0) {
            return function(value, callback) {
                callback();
            }
        }

        var params = retrieveActionParams($deleteBtn);

        var deleteUrlParams = {
            conceptId: params.conceptId,
            relationForDelete: params.relationForDelete,
            action: ACTION.DELETE
        };

        doPlatformActions([[$deleteBtn[0], toUrlParams(deleteUrlParams)]], $block, callback);
    };
};function Vertex( name, specifiers, interface_specifier, sort ) {
    this.name = name;
    this.specifiers = specifiers;
    this.interface_specifier = interface_specifier;
    this.interface_params = {};
    this.sort = sort;
    this.children = [];
    this.produced = false;
}

Vertex.prototype.produce = function() {
    this.produced = true;
};

Vertex.prototype.transformToCollection = function(orientation) {
    var traversal = [],
        queue = [],
        collection;

    queue.push( this );

    while ( queue.length ) {
        var current = queue.pop();

        if ( !in_array( current, traversal ) ) {
            traversal.push( current );

            if ( intersect(current.specifiers, [SPECIFIER.SET, SPECIFIER.SETMM, SPECIFIER.LIST, SPECIFIER.LISTMM, SPECIFIER.ONE, SPECIFIER.ONEMM]).length > 0 ) {
                collection = current;
                break;
            }

            for ( var i = 0; i < current.children.length; i++ ) {
                queue.push( current.children[i] );
            }
        }
    }

    if (!collection) {
        collection = this;
    }

    collection.interface_params = {
        ORIENTATION: orientation
    };

    collection.interface_specifier = INTERFACE_SPECIFIER.COLLECTION;

    return this;
};

Vertex.prototype.simplifyCollection = function() {
    if ( this.specifiers ) {
        for ( var i = this.specifiers.length - 1; i >= 0 ; i-- ) {
            if ( in_array(this.specifiers[i], [SPECIFIER.SET, SPECIFIER.SETMM, SPECIFIER.LIST, SPECIFIER.LISTMM, SPECIFIER.ONE, SPECIFIER.ONEMM]) ) {
                this.specifiers.splice( i, 1 );
            }
        }
    }

    this.interface_specifier = INTERFACE_SPECIFIER.UNDEFINED;

    return this;
};

Vertex.prototype.updateSpecifier = function() {
    if ( intersect( this.specifiers, [
            SPECIFIER.SET, SPECIFIER.SETMM,
            SPECIFIER.LIST, SPECIFIER.LISTMM,
            SPECIFIER.COPY, SPECIFIER.COPYMM,
            SPECIFIER.ONE, SPECIFIER.ONEMM ] ).length === 0 ) {

        this.specifiers.push( ( this.sort ? SPECIFIER.ONE : SPECIFIER.COPY) );
    }
    return this;
};

Vertex.prototype.getInterfaceSpecifier = function() {
    var interface_specifier = "";

    if (interface_specifier == INTERFACE_SPECIFIER.UNDEFINED) {
        if ( intersect([SPECIFIER.SET,SPECIFIER.SETMM,
                SPECIFIER.LIST,SPECIFIER.LISTMM,
                SPECIFIER.ONEMM], this.specifiers).length > 0
            || (in_array(SPECIFIER.ONE, this.specifiers) && !this.sort)
        ) {
            interface_specifier = INTERFACE_SPECIFIER.COLLECTION;
        } else if ( this.sort ) {
            switch ( this.sort ) {
                case TERMINAL.SORT.STR : interface_specifier = INTERFACE_SPECIFIER.STRING; break;
                case TERMINAL.SORT.INT : interface_specifier = INTERFACE_SPECIFIER.INTEGER; break;
                case TERMINAL.SORT.REAL : interface_specifier = INTERFACE_SPECIFIER.REAL; break;
                case TERMINAL.SORT.BOOL : interface_specifier = INTERFACE_SPECIFIER.BOOLEAN; break;
                case TERMINAL.SORT.DATE : interface_specifier = INTERFACE_SPECIFIER.DATETIME; break;
                case TERMINAL.SORT.BLOB : interface_specifier = INTERFACE_SPECIFIER.BLOB; break;
                default : {
                    if ( this.sort.match( TERMINAL.VALUE.STR ) || this.sort.match( TERMINAL.VALUE.INT )
                        || this.sort.match( TERMINAL.VALUE.REAL ) || this.sort.match( TERMINAL.VALUE.BOOL )
                        || this.sort.match( TERMINAL.VALUE.DATE ) || this.sort.match( TERMINAL.VALUE.BLOB ) ) {
                        interface_specifier = INTERFACE_SPECIFIER.TERMINAL_VALUE;
                    } else {
                        interface_specifier = INTERFACE_SPECIFIER.UNDEFINED;
                    }
                    break;
                }
            }
        } else if ( in_array( SPECIFIER.ALT, this.specifiers ) )  {
            interface_specifier = INTERFACE_SPECIFIER.ALT;
        } else {
            interface_specifier = INTERFACE_SPECIFIER.COMPLEX;
        }
    }

    return interface_specifier;
};

Vertex.prototype.updateInterfaceSpecifier = function() {
    this.interface_specifier = this.getInterfaceSpecifier();

    return this;
};

Vertex.prototype.toHtmlName = function() {
    return (this.name + (this.sort ? ' ' + TRANSLATE_SORT[this.sort] : ''));
};;function AbstractVertex( $block, meta ) {
    meta.updateInterfaceSpecifier();

    var _class;

    switch ( meta.interface_specifier ) {
        case INTERFACE_SPECIFIER.COLLECTION :     _class = CollectionVertex; break;

        case INTERFACE_SPECIFIER.ALT :            _class = AltVertex; break;
        case INTERFACE_SPECIFIER.COMPLEX :        _class = ComplexVertex; break;
        case INTERFACE_SPECIFIER.BOOLEAN :        _class = BooleanVertex; break;
        case INTERFACE_SPECIFIER.DATETIME :       _class = DatetimeVertex; break;
        case INTERFACE_SPECIFIER.STRING :         _class = StringVertex; break;
        case INTERFACE_SPECIFIER.INTEGER :        _class = IntegerVertex; break;
        case INTERFACE_SPECIFIER.REAL :           _class = RealVertex; break;
        case INTERFACE_SPECIFIER.BLOB :           _class = BlobVertex; break;
        case INTERFACE_SPECIFIER.TERMINAL_VALUE : _class = TerminalVertex; break;
        default :                                 _class = function() {return null;}
    }

    return _class( $block, meta );
};function IrParser() {

    return {
        toJson: function IrToJson( text ) {
            var current_pos = 0,
                tree = new Vertex( "tree", [SPECIFIER.COPY,SPECIFIER.PROXY], INTERFACE_SPECIFIER.COMPLEX, null ),
                stack = [tree],
                current_vertex;

            while ( current_pos < text.length && stack.length > 0 ) {
                var full_name = get_full_name( text, current_pos );

                current_pos = current_pos + full_name.length + 1;

                current_vertex = stack.pop();

                if ( !full_name.trim().length ) continue;

                var _specifiers = full_name.match( SPECIFIER.REGULAR_EXPR ),
                    _interface_specifier = full_name.match( INTERFACE_SPECIFIER.REGULAR_EXPR ),
                    _sort = full_name.match( TERMINAL.REGULAR_EXPR ),

                    specifiers = ( ( _specifiers ) ? _specifiers : [] ),
                    interface_specifier = ( ( _interface_specifier ) ? _interface_specifier[0] : INTERFACE_SPECIFIER.UNDEFINED ),
                    sort = ( ( _sort ) ? _sort[0] : null );

                var name = full_name.replace( SPECIFIER.REGULAR_EXPR, "" )
                    .replace( INTERFACE_SPECIFIER.REGULAR_EXPR, "" )
                    .replace( TERMINAL.REGULAR_EXPR, "" )
                    .trim();

                var toPushVertex = new Vertex( name, specifiers, interface_specifier, sort );
                toPushVertex.updateSpecifier().updateInterfaceSpecifier();

                current_vertex.children.push( toPushVertex );
                stack.push( current_vertex );

                if ( text[current_pos-1] == "{" ) {
                    stack.push( current_vertex.children[current_vertex.children.length-1] );
                }
            }

            return tree.children[0];
        },

        toIr: function ( json ) {
            return putVertex( json, 0 );
        }
    };

    function putVertex( vertex, level ) {
        var text = "";

        if ( vertex.length >= 0 ) {
            for ( var i = 0; i < vertex.length; i++ ) {
                text = text + putVertex( vertex[i], level );
            }
            return text;
        }

        for ( var i = 0; i < level*2; i++ ) {
            text = text + " ";
        }

        text = text + vertex.name;

        if ( vertex.sort ) {
            if ( vertex.children.length > 0 ) {
                text = text + ' ' + vertex.sort + " ";
            } else {
                text = text + vertex.sort + "\n";
            }
        }

        if ( !vertex.sort || vertex.children.length > 0) {
            text = text + " {\n";
            for ( var i = 0; i < vertex.children.length; i++ ) {
                text = text + putVertex( vertex.children[i], level + 1 );
            }
            for ( var i = 0; i < level*2; i++ ) {
                text = text + " ";
            }
            text = text + "}\n";
        }

        return text;
    }

    function get_full_name( text, current_pos ) {
        var line, lines = [];

        /* Костыль для ссылок */
        line = text.substring( current_pos ).match( /^[\s\S]*?;/ );
        if ( line ) {lines.push( line[0] );}

        line = text.substring( current_pos ).match( /^[\s\S]*?[\s\S](?={)/ );
        if ( line ) lines.push( line[0] );

        line = text.substring( current_pos ).match( /^[\s\S]*?]/ );
        if ( line ) lines.push( line[0] );

        line = text.substring( current_pos ).match( /^[\s]*(?=})/ );
        if ( line ) lines.push( line[0] );

        line = "";

        for ( var i = 0; i < lines.length; i++ ) {
            if ( !line.length ) {
                line = lines[i];
            }
            if ( lines[i].length < line.length && (lines[i].trim() !== line.trim()) ){
                line = lines[i];
            }
        }

        return line;
    }
};function CollectionVertex( $block, meta ) {
    var data = $block.data('collection');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        element_meta: clone( meta ),
        elements: [],
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    var defaultConfig = {
        ORIENTATION: COLLECTION_ORIENTATION.HORIZONTAL
    };

    var config = $.extend(defaultConfig, meta.interface_params);

    /* init DOM */
    var _orientation = in_array(config.ORIENTATION, [COLLECTION_ORIENTATION.HORIZONTAL,COLLECTION_ORIENTATION.VERTICAL]) ?  config.ORIENTATION : COLLECTION_ORIENTATION.HORIZONTAL;
    var _type = intersect( self.meta.specifiers, [ SPECIFIER.SET, SPECIFIER.SETMM ] ).length > 0
        || ( intersect( self.meta.specifiers, [ SPECIFIER.ONE, SPECIFIER.ONEMM ] ).length > 0 && !self.meta.sort )
        ? COLLECTION_TYPE.SET
        : COLLECTION_TYPE.LIST;

    self.element_meta.simplifyCollection();

    var _traversal = get_first_traversal( self.element_meta );
    var _leafs = get_leafs( _traversal );

    var _width = get_width( self.element_meta );
    var _height = get_height( self.element_meta );

    self.element_meta.level = 0;
    self.element_meta.width = _width;
    self.element_meta.height = _height;

    if ( intersect( self.meta.specifiers, [ SPECIFIER.ONE, SPECIFIER.COPY ] ).length > 0 ) {
        self.min_elements = 1;
        self.max_elements = 1;
    } else if ( intersect( self.meta.specifiers, [ SPECIFIER.ONEMM, SPECIFIER.COPYMM ] ).length > 0 ) {
        self.min_elements = 0;
        self.max_elements = 1;
    } else if ( intersect( self.meta.specifiers, [ SPECIFIER.SET, SPECIFIER.LIST ] ).length > 0 ) {
        self.min_elements = 1;
        self.max_elements = 100000;
    } else if ( intersect( self.meta.specifiers, [ SPECIFIER.SETMM, SPECIFIER.LISTMM ] ).length > 0 ) {
        self.min_elements = 0;
        self.max_elements = 100000;
    }

    self.elements_count = 0;

    var matrix = get_matrix( _orientation, _width, _height, _traversal );

    var form = get_collection_block( matrix );

    $( form ).children().appendTo( self );
    self.addClass("collection_block")
        .addClass( _orientation == COLLECTION_ORIENTATION.HORIZONTAL ? "collection_horizontal" : "collection_vertical" )
        .data('collection', self)
        .data('type', 'collection');

    while ( self.elements_count < self.min_elements ) {
        add_element();
    }

    update_buttons();

    return self;

    /** TODO: refactor */
    function updateIweConcepts($iweBlock) {
        /* produce */
        self.produce = getIweProduceFunction($iweBlock, self, self.meta);
        self.delete = getIweDeleteFunction($iweBlock, self, self.meta);

        var infos = getIweInfos($iweBlock, self.meta),
            allow_produce_nesting = true,
            allow_update_children = true;

        for ( var i = 0; i < self.elements.length; i++ ) {
            if (infos.eq(i).length === 0) {
                if (!self.elements[i].produced) {
                    self.elements[i].produce();
                    self.produce();
                }
                allow_produce_nesting = false;
            }
        }

        if (allow_produce_nesting) {
            for ( var j = 0; j < self.elements.length; j++ ) {
                var traversal = [],
                    queue = [],
                    queue_block =[];

                queue.push( self.elements[j] );
                queue_block.push( infos.eq(j) );

                while ( queue.length ) {
                    var current = queue.pop();
                    var $current_block = queue_block.pop();

                    if ( !in_array( current, traversal ) ) {
                        traversal.push( current );

                        if ( isHeaderVertex( current ) && current !== self.elements[j]) {
                            var cur_inf = getIweInfos($current_block, current, true);

                            if (current.interface_specifier === INTERFACE_SPECIFIER.COLLECTION) {
                            } else if (cur_inf.length === 0) {
                                if (!current.produced) {
                                    current.produce();
                                    var produce = getIweProduceFunction($current_block, self, current, true);
                                    produce(function () {
                                    });
                                }
                                allow_update_children = false;
                            }
                        }

                        if ( isHeaderVertex( current ) ) {
                            if (current === self.elements[j] || cur_inf.length !== 0) {
                                for (var i = 0; i < current.children.length; i++) {
                                    var ch_inf = getIweInfos($current_block, current.children[i]);

                                    if (current.children[i].interface_specifier === INTERFACE_SPECIFIER.COLLECTION) {
                                        queue_block.push($current_block);
                                        queue.push(current.children[i]);
                                    } else if (ch_inf.length === 0) {
                                        if (!current.children[i].produced) {
                                            current.children[i].produce();
                                            var produce = getIweProduceFunction($current_block, self, current.children[i]);
                                            produce(function () {
                                            });
                                        }
                                        allow_update_children = false;
                                    } else {
                                        queue_block.push(ch_inf.eq(0));
                                        queue.push(current.children[i]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            allow_update_children = false;
        }

        /* update childs */
        if (allow_update_children) {
            var list = self.find( '>table' ),
                size = get_size_from_blocks( _orientation, _height, list );

            infos.map(function(index, iweBlock) {
                try {
                    var leafs_blocks = get_leafs_blocks(list, size, index);

                    update_leafs_concepts( $(iweBlock), leafs_blocks, self.elements[index]);
                } catch (e) {}
            });
        }
    }

    function update_leafs_concepts( $iweBlock, leafs_blocks, element_metainf ) {
        var traversal_meta = [],
            queue_meta = [],
            traversal_block = [],
            queue_block = [];

        queue_meta.push( clone(element_metainf) );
        queue_block.push( clone($iweBlock) );

        while ( queue_meta.length ) {

            var current_meta = queue_meta.pop(),
                $current_block = queue_block.pop();

            //if (current_info instanceof Vertex) {
            //    sortArrayByMeta( current_info.children, current_meta.children);
            //}

            traversal_meta.push( current_meta );

            if ( isHeaderVertex( current_meta ) ) {
                for ( var i = 0; i < current_meta.children.length; i++ ) {
                    var cur_inf = getIweInfos($current_block, current_meta.children[i]);

                    if (current_meta.children[i].interface_specifier === INTERFACE_SPECIFIER.COLLECTION) {
                        queue_block.push( $current_block );
                    } else {
                        queue_block.push( cur_inf.eq(0) );
                    }

                    queue_meta.push( current_meta.children[i] );
                }
            } else {
                traversal_block.push( $current_block );
            }
        }

        for ( var i = traversal_meta.length - 1; i >= 0; i-- ) {
            if ( isHeaderVertex( traversal_meta[i] ) ) {
                traversal_meta.splice( i, 1 );
            }
        }

        if ( traversal_meta.length === 0 ) {
            traversal_meta.push( element_metainf );
            traversal_block.push( $iweBlock );
        }

        while ( traversal_meta.length > 0 ) {
            current_meta = traversal_meta.shift();
            $current_block = traversal_block.shift();

            AbstractVertex( $( leafs_blocks.pop() ), current_meta ).updateIweConcepts( $current_block );
        }
    }

    function getInfo() {
        var list = self.find( '>table' ),
            collection = [],
            size = get_size_from_blocks( _orientation, _height, list );

        for ( var i = 0; i < size ; i++ ) {
            var leafs_blocks = get_leafs_blocks(list, size, i);

            var info = merge_leafs_val_with_meta( leafs_blocks, self.element_meta );

            if ( _type == COLLECTION_TYPE.SET ) {
                /* define element name */
                if (_orientation == COLLECTION_ORIENTATION.HORIZONTAL) {
                    info.sort = TO.NAME( list.find('>tr:nth-child(' + (i + _height + 1) + ')>*:first-child>.name').val() );
                } else {
                    info.sort = TO.NAME( list.find('>tr:first-child>*:nth-child(' + (i + 2) + ')>.name').val() );
                }
            }

            collection.push( info );
        }

        return collection;
    }

    function setInfo( info ) {
        var elementsOfSet = [],
            list = self.find( '>table' ),
            size = get_size_from_blocks( _orientation, _height, list );

        if (info instanceof Vertex) {
            info = [info];
        }

        if (info.length > 0) {
            var k = 0;
            while ( info[k] && self.element_meta.name == info[k].name ) {
                elementsOfSet.push( info[k] );
                k++;
            }

            while ( size < elementsOfSet.length ) {
                add_element();
                size++;
            }

            for ( var i = 0; i < size ; i++ ) {
                var leafs_blocks = get_leafs_blocks(list, size, i);

                try {
                    self.elements[i].produce();
                    put_info_leafs_vals( elementsOfSet[i], leafs_blocks, self.element_meta );
                } catch (e) {
                    console.log('You have incorrect info in meta: ' + self.meta.name );
                }

                if ( _type == COLLECTION_TYPE.SET ) {
                    /* define element name */
                    if (_orientation == COLLECTION_ORIENTATION.HORIZONTAL) {
                        list.find('>tr:nth-child(' + (i + _height + 1) + ')>*:first-child>.name').val( FROM.NAME(elementsOfSet[i].sort) );
                    } else {
                        list.find('>tr:first-child>*:nth-child(' + (i + 2) + ')>.name').val( FROM.NAME(elementsOfSet[i].sort) );
                    }
                }
            }
        }

        return self;
    }

    function get_collection_block( matrix ) {
        var table_block = document.createElement( 'div' );

        table_block.appendChild( form_table( matrix ) );

        var add_btn = generate_add_button();

        /* append HORIZONTAL CONTROL HEADINGS for HORIZONTAL orientation */
        if (_orientation == COLLECTION_ORIENTATION.HORIZONTAL) {
            var _index = in_array( SPECIFIER.PROXY, self.meta.specifiers ) ? 1 : 0;

            if ( _type == COLLECTION_TYPE.SET ) {
                $( document.createElement( 'th' ) )
                    .attr( 'rowSpan', _height - _index )
                    .text( 'Имя элемента' )
                    .insertBefore(
                        $( table_block )
                            .find( '>table' )
                            .children()
                            .eq( _index )
                            .find('>*:first-child' )
                    )
                ;
            }

            $( document.createElement( 'th' ) )
                .attr( 'rowSpan', _height - _index )
                .insertAfter(
                    $( table_block )
                        .find( '>table' )
                        .children()
                        .eq( _index )
                        .find('>*:last-child' )
                )
            ;

        /* append VERTICAL CONTROL HEADINGS for VERTICAL orientation */
        } else {
            var tr_name = document.createElement( 'tr' );
            var th_name = document.createElement( 'th' );
            tr_name.appendChild(th_name);

            var tr_control = document.createElement( 'tr' );
            var th_control = document.createElement( 'th' );
            tr_control.appendChild(th_control);

            if ( _type == COLLECTION_TYPE.SET ) {
                $( th_name )
                    .attr( 'colSpan', _height )
                    .text( 'Имя элемента' );
                $( tr_name )
                    .insertBefore( $( table_block ).find( '>table>tr:first-child' ) );
            }

            $( th_control )
                .attr( 'colSpan', _height );
            $( tr_control )
                .insertAfter( $( table_block ).find( '>table>tr:last-child' ) );
        }

        /* append ADD button for HORIZONTAL orientation */
        var tr, head_part;

        if (_orientation == COLLECTION_ORIENTATION.HORIZONTAL) {
            tr = table_block.querySelector('table>tr:last-child');
            head_part = document.createElement( 'td' );
            $( head_part ).attr( 'colSpan', '100%' );

            /* append ADD button for VERTICAL orientation */
        } else {
            tr = table_block.querySelector('table>tr:first-child');
            head_part = document.createElement( 'th' );
            $( head_part ).attr( 'rowSpan', _width + 1 + ( _type == COLLECTION_TYPE.SET ? 1 : 0 ) );
        }

        tr.appendChild( head_part );
        head_part.appendChild( add_btn );

        return table_block;
    }

    function get_leafs_blocks(list, size, i) {
        var leafs_blocks = [],
            list_children, j;

        if ( _orientation == COLLECTION_ORIENTATION.HORIZONTAL ) {
            list_children = list.find('>tr:nth-child(' + (i + _height + 1) + ')>*');

            for ( j = _type == COLLECTION_TYPE.SET ? 1 : 0; j < list_children.length - 1; j++ ) {
                leafs_blocks.push( list_children.eq(j).find('>div') );
            }
        } else {
            for ( j = _width + (_type == COLLECTION_TYPE.SET ? 0 : -1); j >= (_type == COLLECTION_TYPE.SET ? 1 : 0); j-- ) {
                list_children = list.find('>tr').eq(j).children();
                leafs_blocks.push( list_children.eq(list_children.length - size + i - ( j === 0 ? 1 : 0) ).find( 'div' ) );
            }
        }

        return leafs_blocks;
    }

    function get_size_from_blocks( type, height, table ) {
        var size = 0;

        if ( type == COLLECTION_ORIENTATION.HORIZONTAL ) {
            size = table.children().length - height - 1;
        } else {
            var table_children = table.find( '>tr:first-child>*' );
            for ( var j = 0; j < table_children.length; j++ ) {
                if ( !table_children.eq(j).is('th') ) {
                    size++;
                }
            }
        }

        return size;
    }

    function put_info_leafs_vals( info, leafs_blocks, element_metainf ) {
        var traversal_meta = [],
            queue_meta = [],
            traversal_info = [],
            queue_info = [];

        queue_meta.push( clone(element_metainf) );
        queue_info.push( clone(info) );

        while ( queue_meta.length ) {

            var current_meta = queue_meta.pop(),
                current_info = queue_info.pop();

            if (current_info instanceof Vertex) {
                sortArrayByMeta( current_info.children, current_meta.children);
            }

            traversal_meta.push( current_meta );

            if ( isHeaderVertex( current_meta ) ) {
                var k = 0;

                for ( var i = 0; i < current_meta.children.length; i++ ) {
                    queue_meta.push( current_meta.children[i] );

                    if ( current_meta.children[i].interface_specifier == INTERFACE_SPECIFIER.COLLECTION ) {
                        var elementsofset = [];
                        while ( current_info.children[i + k] && current_meta.children[i].name == current_info.children[i + k].name ) {
                            elementsofset.push( current_info.children[i + k] );
                            k++;
                        }
                        k--;
                        queue_info.push( elementsofset );
                    } else {
                        queue_info.push( current_info.children[i+k] );
                    }
                }
            } else {
                traversal_info.push( current_info );
            }
        }

        for ( var i = traversal_meta.length - 1; i >= 0; i-- ) {
            if ( isHeaderVertex( traversal_meta[i] ) ) {
                traversal_meta.splice( i, 1 );
            }
        }

        if ( traversal_meta.length === 0 ) {
            traversal_meta.push( element_metainf );
            traversal_info.push( info );
        }

        while ( traversal_meta.length > 0 ) {
            current_meta = traversal_meta.shift();
            current_info = traversal_info.shift();

            AbstractVertex( $( leafs_blocks.pop() ), current_meta ).setInfo( current_info );
        }
    }

    function merge_leafs_val_with_meta( leafs_vals, element_metainf ) {
        var vertex = clone( element_metainf ),
            queue = [],
            current, i;

        queue.push( vertex );

        while ( queue.length ) {
            current = queue.pop();

            if ( !isHeaderVertex( current ) ) {
                var info = AbstractVertex( $( leafs_vals.pop() ), current ).getInfo();

                if ( info ) {
                    if ( info.length >= 0 ) {
                        var index = 0,
                            parent = current.parent;

                        while( parent.children[index].name != current.name ) {
                            index++;
                        }

                        if (info.length === 0) {
                            parent.children.splice(index, 1);
                        } else {
                            parent.children[index] = info[0];
                            index++;
                        }


                        for (i = 1; i < info.length; i++) {
                            parent.children.splice(index, 0, info[i]);
                            index++;
                        }
                    } else {
                        current.sort = info.sort;
                        current.children = info.children;
                    }
                }
            } else {
                for ( i = 0; i < current.children.length; i++ ) {
                    current.children[i].parent = current;
                    queue.push( current.children[i] );
                }
            }
        }

        return vertex;
    }

    function add_element() {
        self.elements_count++;
        self.elements.push(clone(self.element_meta));

        if ( self.element_meta.sort ) {
            var td = document.createElement( 'td' ),
                block = document.createElement( 'div' );

            if ( !in_array( SPECIFIER.PROXY, _leafs[0].specifiers ) ) {
                _leafs[0].specifiers.push( SPECIFIER.PROXY );
            }

            $( td ).append( AbstractVertex( $( block ), _leafs[0] ) );

            if ( _orientation == COLLECTION_ORIENTATION.HORIZONTAL ) {
                var tr = document.createElement( 'tr' );
                tr.appendChild( td );

                $( tr ).insertBefore( self.find( '>table>tr:last-child' ) );
                append_horizontal_controls();
            } else {
                append_vertical_controls();

                if ( _type == COLLECTION_TYPE.SET ) {
                    $( td ).insertAfter( self.find( '>table>tr:nth-child(2)>*:last-child' ) );
                } else {
                    $( td ).insertBefore( self.find( '>table>tr:first-child>*:last-child' ) );
                }
            }
        } else {
            var tr = document.createElement( 'tr' );

            for ( var i =  _leafs.length - 1; i >= 0; i-- ) {
                var td = document.createElement( 'td' ),
                    block = document.createElement( 'div' );

                if ( !in_array( SPECIFIER.PROXY, _leafs[i].specifiers ) ) {
                    _leafs[i].specifiers.push( SPECIFIER.PROXY );
                }

                $( td ).append( AbstractVertex( $( block ), _leafs[i] ) );

                if ( _orientation == COLLECTION_ORIENTATION.HORIZONTAL ) {
                    tr.appendChild( td );
                } else {
                    if ( i == 0 ) {
                        if ( _type == COLLECTION_TYPE.SET ) {
                            $( td ).insertAfter( self.find( '>table>tr:nth-child(2)>*:last-child' ) );
                        } else {
                            $( td ).insertBefore( self.find( '>table>tr:first-child>*:last-child' ) );
                        }
                    } else {
                        self.find( '>table' ).children().eq(i + ( _type == COLLECTION_TYPE.SET ? 1 : 0)).append( td );
                    }
                }
            }

            if ( _orientation == COLLECTION_ORIENTATION.HORIZONTAL ) {
                $( tr ).insertBefore( self.find( '>table>tr:last-child' ) );
                append_horizontal_controls();
            } else {
                append_vertical_controls();
            }
        }

        update_buttons();
    }

    function remove_horizontal_element($tr) {
        return function() {
            var index = $tr.index() - _height;

            self.delete(index, function(res) {
                self.elements.splice(index, 1);

                $tr.remove();

                self.elements_count--;
                update_buttons();
            });
        }
    }

    function remove_vertical_element() {
        var btn = $( this );
        var index = btn.parent().index() - 1;

        self.delete(index, function() {
            self.elements.splice(index,1);

            var $td = btn.parent();
            var i = -1;

            while ($td.next().length > 0) {
                $td = $td.next();
                i--;
            }

            var rows = self.find('>table>tr');

            for (var j = 0; j < rows.length; j++) {
                rows.eq(j).children().eq(i - ( j === 0 ? 1 : 0)).remove();
            }

            self.elements_count--;
            update_buttons();
        });
    }

    function generate_add_button() {
        var add_btn = document.createElement( 'button' );
        add_btn.textContent = '+ Добавить';
        add_btn.onclick = function() {
            self.produce(fixElementsOrder);
        };

        $( add_btn ).addClass('add');

        return add_btn;
    }

    function create_remove_button() {
        var remove_btn = document.createElement('button');
        remove_btn.textContent = '- Удалить';
        $(remove_btn).addClass('remove');

        return remove_btn;
    }

    function create_name_field() {
        var name_field = document.createElement('input');
        name_field.value = self.meta.name;
        $(name_field).addClass('name');

        return name_field;
    }

    function append_horizontal_controls() {
        if ( _orientation == COLLECTION_ORIENTATION.HORIZONTAL ) {
            var remove_btn_block = document.createElement('td');
            var remove_btn = create_remove_button();
            remove_btn_block.appendChild(remove_btn);

            var $tr = self.find('>table>tr:last-child').prev();

            if (_type === COLLECTION_TYPE.SET) {
                $( document.createElement('td') )
                    .insertBefore($tr.find('>*:first-child'))
                    .append( create_name_field() );
            }

            remove_btn.onclick = remove_horizontal_element($tr);

            $(remove_btn_block)
                .insertAfter($tr.find('>*:last-child'));
        }
    }

    function append_vertical_controls() {
        if ( _type === COLLECTION_TYPE.SET ) {
            $( document.createElement('td') )
                .insertBefore( self.find( '>table>tr:first-child>*:last-child' ) )
                .append( create_name_field() );
        }

        var remove_btn_block = document.createElement('td');
        var remove_btn = create_remove_button();
        remove_btn_block.appendChild(remove_btn);

        remove_btn.onclick = remove_vertical_element;

        $( remove_btn_block )
            .insertAfter( self.find( '>table>tr:last-child>*:last-child' ) );
    }

    function update_buttons() {
        getAddButton().attr( 'disabled', !( self.elements_count < self.max_elements ) );
        getRemoveButtons().attr( 'disabled', !( self.elements_count > self.min_elements ) );
    }

    function getAddButton() {
        return self.find( '>table>tr>*>.add' );
    }

    function getRemoveButtons() {
        return self.find( '>table>tr>*>.remove' );
    }

    function form_table( matrix ) {
        var table = document.createElement( 'table' );

        for ( var i = 0; i < matrix.length; i++ ) {
            var tr = document.createElement( 'tr' );

            for ( var j = 0; j < matrix[i].length; j++ ) {
                var th = document.createElement( 'th' );
                th.colSpan = matrix[i][j].colSpan;
                th.rowSpan = matrix[i][j].rowSpan;
                th.textContent = matrix[i][j].textContent;
                tr.appendChild( th );
            }

            table.appendChild( tr );
        }

        return table;
    }

    function get_matrix( type, width, height, traversal ) {
        traversal = clone( traversal );

        return ( ( type == COLLECTION_ORIENTATION.VERTICAL )
            ? get_vertical_matrix( width, height, traversal )
            : get_horizontal_matrix( width, height, traversal ) );
    }

    function get_vertical_matrix( width, height, traversal ) {
        var matrix = [],
            current;

        for ( var i = 0; i < width; i++ ) {
            matrix[i] = [];
        }

        var row_height = 0,
            current_row = 0;

        if ( in_array( SPECIFIER.PROXY, traversal[0].specifiers ) ) {
            traversal.shift();
            row_height = 1;
        }

        while ( current = traversal.shift() ) {

            var height_inc = ( isHeaderVertex( current ) ? 1 : ( height - current.level ) );

            if ( row_height >= height ) {
                row_height = current.level;
                current_row++;
            }

            matrix[current_row].push({
                rowSpan : current.width,
                colSpan : height_inc,
                textContent : ( ( in_array( SPECIFIER.PROXY, current.specifiers ) ) ? "" : current.name )
            });

            row_height = row_height + height_inc;
        }

        return matrix;
    }

    function get_horizontal_matrix( width, height, traversal ) {
        var matrix = [],
            current;

        for ( var i = 0; i <= height; i++ ) {
            matrix[i] = [];
        }

        if ( in_array( SPECIFIER.PROXY, traversal[0].specifiers ) ) {
            traversal.shift();
        }

        while ( current = traversal.pop() ) {
            matrix[current.level].push({
                rowSpan : ( isHeaderVertex( current ) ? 1 : ( height - current.level ) ),
                colSpan : current.width,
                textContent : ( ( in_array( SPECIFIER.PROXY, current.specifiers ) ) ? "" : current.name )
            });
        }

        return matrix;
    }

    function get_leafs( traversal ) {
        var leafs = [];

        /* for simple vertex */
        if (traversal.length === 1) {
            return [traversal[0]];
        }

        /* for complex vertex */
        for ( var i = 0; i < traversal.length; i++ ) {
            if ( !isHeaderVertex( traversal[i] ) ) {
                leafs.push(traversal[i]);
            }
        }

        return leafs;
    }

    function get_first_traversal( element_metainf ) {
        var traversal = [],
            queue = [];

        queue.push( element_metainf );

        while ( queue.length ) {

            var current = queue.pop();

            if ( !in_array( current, traversal ) ) {
                traversal.push( current );
                if ( isHeaderVertex( current ) ) {
                    for ( var i = 0; i < current.children.length; i++ ) {
                        queue.push( current.children[i] );
                    }
                }
            }
        }

        return traversal;
    }

    function get_height( vertex, level ) {
        var height = 1;
        level = level || 1;

        if ( isHeaderVertex( vertex ) ) {
            vertex.children.forEach( function( child ) {
                child.height = get_height( child, level + 1 );
                child.level = level;
                height =  Math.max( height, child.height + 1 );
            });
        }

        return height;
    }

    function get_width( vertex ) {
        var width = 0;

        if ( isHeaderVertex( vertex ) && vertex.children.length ) {
            vertex.children.forEach( function( child ) {
                child.width = get_width( child );
                width = width + child.width;
            });
        } else {
            width = 1;
        }

        return width;
    }

    function isHeaderVertex( vertex ) {
        return in_array( vertex.interface_specifier, [INTERFACE_SPECIFIER.UNDEFINED, INTERFACE_SPECIFIER.COMPLEX] );
    }

    function fixElementsOrder(res) {
        var win = self.closest('div.iacpaas-window');
        var currentTabIdx = parseInt(win.attr('current-tab'));
        var currentTab = win.find('div#iacpaas-tabs div#iacpaas-tab-' + (currentTabIdx + 1));
        if (currentTab.length == 0)
            currentTab = win;

        var r;
        if ((r = /\$REDIRECT\$:(.*)$/.exec(res)) != null)
            window.location = r[1];
        else
            currentTab[0].innerHTML = res;

        vivify();
    }
};function ComplexVertex( $block, meta ) {
    var data = $block.data('complex');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_complex_block( meta, label );

    $( form ).children().appendTo( self );
    self.addClass("complex_block")
        .data('complex', self)
        .data('type', 'complex');

    return self;

    function updateIweConcepts($iweBlock) {
        var title_shift = ( self.children()[0].nodeName == "H2" ? 1 : 0);

        for ( var i = 0; i < self.meta.children.length; i++ ) {
            var child_meta = self.meta.children[i];
            var $child_block = $( self.children().get(i + title_shift) );

            var infos = getIweInfos($iweBlock, child_meta);

            if (child_meta.interface_specifier === INTERFACE_SPECIFIER.COLLECTION) {
                AbstractVertex( $child_block, child_meta )
                    .updateIweConcepts($iweBlock);
            } else if (infos.length === 0) {
                if (!child_meta.produced) {
                    child_meta.produce();
                    var produce = getIweProduceFunction($iweBlock, $child_block, child_meta);
                    produce(function() {});
                }
            } else {
                AbstractVertex( $child_block, child_meta )
                    .updateIweConcepts(infos.eq(0));
            }
        }
    }

    function getInfo() {
        var title_shift = ( self.children()[0].nodeName == "H2" ? 1 : 0),
            vertex = new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, self.meta.sort );

        for ( var i = 0; i < self.meta.children.length; i++ ) {
            var info = AbstractVertex( $( self.children().get(i + title_shift) ), self.meta.children[i] ).getInfo();

            if ( !info ) {
                return;
            } else if ( info.length ) {
                for ( var j = 0; j < info.length; j++ ) {
                    vertex.children.push( info[j] );
                }
            } else {
                vertex.children.push( info );
            }
        }

        return vertex;
    }

    function setInfo( info ) {
        var title_shift = self.children().eq(0).is('h2') ? 1 : 0,
            k = 0,
            elem;

        if (info instanceof Vertex) {
            sortArrayByMeta( info.children, self.meta.children);
        }


        for ( var i = 0; i < self.meta.children.length; i++ ) {
            try {
                if ( self.meta.children[i].interface_specifier == INTERFACE_SPECIFIER.COLLECTION ) {
                    var elementsOfSet = [];
                    while ( info.children[i + k] && self.meta.children[i].name == info.children[i + k].name ) {
                        elementsOfSet.push( info.children[i + k] );
                        k++;
                    }
                    k--;

                    elem = elementsOfSet;
                } else {
                    elem = info.children[i + k];
                }

                AbstractVertex( $( self.children().get(i + title_shift) ), self.meta.children[i] ).setInfo( elem );
            } catch (e) {
                console.log('You have incorrect info in meta: ' + self.meta.children[i].name );
            }
        }

        return self;
    }

    function get_complex_block( element_metainf, title ) {
        var complex_block = document.createElement( 'div' );

        if ( title ) {
            var ttl = document.createElement( 'h2' );
            ttl.textContent = title;
            complex_block.appendChild( ttl );
        }

        for ( var i = 0; i < element_metainf.children.length; i++ ) {
            var element = document.createElement( 'div' );

            AbstractVertex( $(element), element_metainf.children[i]);

            complex_block.appendChild( element );
        }

        return complex_block;
    }
};function AltVertex( $block, meta ) {
    var data = $block.data('alt');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_alt_block( meta, label );

    $( form ).children().appendTo( self );
    self.addClass("alt_block")
        .data('alt', self)
        .data('type', 'alt');

    return self;

    function getInfo() {
        var list = self.find( 'select' );
        var vertex = new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, null);
        var meta = self.meta.children[list.val()];
        var info = meta.interface_specifier == INTERFACE_SPECIFIER.TERMINAL_VALUE
            ? meta
            : AbstractVertex( $( self.find( 'div' ) ), meta ).getInfo()
        ;

        vertex.children.push( info );

        return vertex;
    }

    function setInfo( info ) {
        var list = self.find( 'select' );

        if (info instanceof Vertex) {
            sortArrayByMeta( info.children, self.meta.children);
        }

        for ( var i = 0; i < list.length; i++ ) {
            if ( ( info.children[0].name != "" && self.meta.children[i].name == info.children[0].name )
                || ( info.children[0].name == "" && self.meta.children[i].sort == info.children[0].sort )
            ) {

                list[i].selected = true;
                $( list ).trigger( 'change' );

                if ( self.meta.children[i].interface_specifier == INTERFACE_SPECIFIER.COLLECTION ) {
                    AbstractVertex( $( self.find( 'div' ) ), self.meta.children[i] ).setInfo( info.children );
                } else {
                    AbstractVertex( $( self.find( 'div' ) ), self.meta.children[i] ).setInfo( info.children[0] );
                }
                break;
            }
        }

        return self;
    }

    function get_alt_block( element_metainf, title ) {
        var alt_block = document.createElement( 'div' ),
            select = document.createElement( 'select' );

        if ( title ) {
            var ttl = document.createElement( 'h1' );
            ttl.textContent = title;
            alt_block.appendChild( ttl );
        }

        for ( var i = 0; i < element_metainf.children.length; i++ ) {
            var option = document.createElement( 'option' );
            if ( element_metainf.children[i].sort ) {
                if ( element_metainf.children[i].sort.match( TERMINAL.SORT.REGULAR_EXPR ) ) {
                    option.text = element_metainf.children[i].name;
                } else {
                    option.text = element_metainf.children[i].sort.match( TERMINAL.VALUE.REGULAR_EXPR )[0];
                }
            } else {
                option.text = element_metainf.children[i].name;
            }
            option.value = i;
            option.name = element_metainf.children[i].name;
            select.add( option );
        }

        alt_block.appendChild( select );
        if ( !element_metainf.children[select.value].sort || element_metainf.children[select.value].sort.match( TERMINAL.SORT.REGULAR_EXPR ) ) {
            var elem = document.createElement( 'div' );
            AbstractVertex( $( elem ), element_metainf.children[select.value] );

            alt_block.appendChild( elem );
        }

        select.onchange = function() {
            if ( self.find( 'div' ) ) {
                self.find( 'div' ).remove();
            }

            if ( !element_metainf.children[select.value].sort || element_metainf.children[select.value].sort.match( TERMINAL.SORT.REGULAR_EXPR ) ) {
                var elem = document.createElement( 'div' );
                AbstractVertex( $( elem ), element_metainf.children[select.value] );

                self.append( elem );
            }
        };

        return alt_block;
    }
};function BooleanVertex( $block, meta ) {
    var data = $block.data('boolean');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_boolean_block( meta, label );

    $( form ).children().appendTo( self );
    self.addClass("boolean_block")
        .data('boolean', self)
        .data('type', 'boolean');

    return self;

    function updateIweConcepts($iweBlock) {
        /* onchange */
        var change = getIweChangeFunction($iweBlock, self, self.meta);

        self.find( 'input' ).unbind( 'change' ).change(function() {
            change( $(this).is(":checked") ? "true" : "false", function() {});
        });
    }

    function getInfo() {
        var value = TO.BOOL( self.find( 'input' ).is(":checked") );

        if ( !value.match( TERMINAL.VALUE.BOOL ) ) {
            self.addClass("error");
            return;
        }
        self.removeClass("error");

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = FROM.BOOL( info.sort ) == 'true';
        self.find( 'input' ).attr('checked', !!value );

        return self;
    }

    function get_boolean_block( element_metainf, title ) {
        var boolean_block = document.createElement( 'div' ),
            label = document.createElement( 'label' ),
            input = document.createElement( 'input' );

        input.type = "checkbox";
        $( input ).attr('checked', !!parseInt(DEFAULT_VALUE[ self.meta.sort ]));

        label.appendChild( input );

        if ( title ) {
            var ttl = document.createElement( 'span' );
            ttl.textContent = title;
            label.appendChild( ttl );
        }

        boolean_block.appendChild( label );

        return boolean_block;
    }
};function DatetimeVertex( $block, meta ) {
    var data = $block.data('datetime');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_datetime_block( meta, label );

    $( form ).children().appendTo( $block );
    self.addClass("datetime_block")
        .data('datetime', self)
        .data('type', 'datetime');

    return self;

    function updateIweConcepts($iweBlock) {
        /* onchange */
        var change = getIweChangeFunction($iweBlock, self, self.meta);

        self.find( 'input' ).unbind( 'change' ).change(function() {
            var value = this.value;

            if ( !value ) {
                self.addClass("error");
                return;
            }

            self.removeClass("error");

            change(formatValue( value ), function() {});
        });
    }

    function formatValue( value ) {
        var year = value.substring(0, 4),
            month = value.substring(5, 7),
            day = value.substring(8, 10),
            hour = value.substring(11, 13),
            min = value.substring(14, 16),
            sec = "00",
            milisec = "000";

        return day + "." + month + "." + year + "-" + hour + ":" + min + ":" + sec + "." + milisec;
    }

    function getInfo() {
        var value = TO.DATE( self.find( 'input' ).val() );

        if ( !value.match( TERMINAL.VALUE.DATE ) ) {
            self.addClass("error");
            return;
        }
        self.removeClass("error");

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = FROM.DATE( info.sort );
        self.find( 'input' ).val( value ? value : "" );

        return self;
    }

    function get_datetime_block( element_metainf, title ) {
        var datetime_block = document.createElement( 'div' ),
            label = document.createElement( 'label' ),
            input = document.createElement( 'input' );

        input.type = "datetime-local";
        $( input ).val( (new Date()).toISOString().substring(0, 16) );

        if ( title ) {
            var ttl = document.createElement( 'span' );
            ttl.textContent = title;
            label.appendChild( ttl );
        }
        label.appendChild( input );

        datetime_block.appendChild( label );

        return datetime_block;
    }
};function StringVertex( $block, meta ) {
    var data = $block.data('string');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_string_block( meta, label );

    $( form ).children().appendTo( self );
    self.addClass("string_block")
        .data('string', self)
        .data('type', 'string');

    return self;

    function updateIweConcepts($iweBlock) {
        /* onchange */
        var change = getIweChangeFunction($iweBlock, self, self.meta);

        self.find( 'input' ).unbind( 'change' ).change(function() {
            var value = this.value;

            if ( !value ) {
                self.addClass("error");
                return;
            }

            self.removeClass("error");

            change(value, function() {});
        });
    }

    function getInfo() {
        var value = TO.STR( self.find( 'input' ).val() );

        if ( !value.match( TERMINAL.VALUE.STR ) ) {
            self.addClass("error");
            return;
        }
        self.removeClass("error");

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = FROM.STR( info.sort );
        self.find( 'input' ).val( value ? value : "" );

        return self;
    }

    function get_string_block( element_metainf, title ) {
        var string_block = document.createElement( 'div' ),
            label = document.createElement( 'label' ),
            input = document.createElement( 'input' );

        input.value = DEFAULT_VALUE[ self.meta.sort ];

        if ( title ) {
            var ttl = document.createElement( 'span' );
            ttl.textContent = title;
            label.appendChild( ttl );
        }

        label.appendChild( input );

        string_block.appendChild( label );

        return string_block;
    }
};function IntegerVertex( $block, meta ) {
    var data = $block.data('integer');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_integer_block( meta, label );

    $( form ).children().appendTo( $block );
    self.addClass("integer_block")
        .data('integer', self)
        .data('type', 'integer');

    return self;

    function updateIweConcepts($iweBlock) {
        /* onchange */
        var change = getIweChangeFunction($iweBlock, self, self.meta);

        self.find( 'input' ).unbind( 'change' ).change(function() {
            var value = this.value;

            var regex = /^-?[0-9]+$/;

            if ( !(regex.test(value)) ) {
                self.addClass("error");
                return;
            }

            self.removeClass("error");

            change(value, function() {});
        });
    }

    function getInfo() {
        var value = TO.INT( self.find( 'input' ).val() );

        if ( !value.match( TERMINAL.VALUE.INT ) ) {
            self.addClass("error");
            return;
        }
        self.removeClass("error");

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = FROM.INT( info.sort );
        self.find( 'input' ).val( value ? value : "" );

        return self;
    }

    function get_integer_block( element_metainf, title ) {
        var integer_block = document.createElement( 'div' ),
            label = document.createElement( 'label' ),
            input = document.createElement( 'input' );

        input.value = DEFAULT_VALUE[ self.meta.sort ];

        if ( title ) {
            var ttl = document.createElement( 'span' );
            ttl.textContent = title;
            label.appendChild( ttl );
        }
        label.appendChild( input );

        integer_block.appendChild( label );

        return integer_block;
    }
};function RealVertex( $block, meta ) {
    var data = $block.data('real');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_real_block( meta, label );

    $( form ).children().appendTo( self );
    self.addClass("real_block")
        .data('real', self)
        .data('type', 'real');

    return self;

    function updateIweConcepts($iweBlock) {
        /* onchange */
        var change = getIweChangeFunction($iweBlock, self, self.meta);

        self.find( 'input' ).unbind( 'change' ).change(function() {
            var value = this.value;

            if ( !(parseInt(value) === value) ) {
                self.addClass("error");
                return;
            }

            self.removeClass("error");

            change(value, function() {});
        });
    }

    function getInfo() {
        var value = TO.REAL( self.find( 'input' ).val() );

        if ( !value.match( TERMINAL.VALUE.REAL ) ) {
            self.addClass("error");
            return;
        }
        self.removeClass("error");

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = FROM.REAL( info.sort );
        self.find( 'input' ).val( value ? value : "" );

        return self;
    }

    function get_real_block( element_metainf, title ) {
        var real_block = document.createElement( 'div' ),
            label = document.createElement( 'label' ),
            input = document.createElement( 'input' );

        input.value = DEFAULT_VALUE[ self.meta.sort ];

        if ( title ) {
            var ttl = document.createElement( 'span' );
            ttl.textContent = title;
            label.appendChild( ttl );
        }
        label.appendChild( input );

        real_block.appendChild( label );

        return real_block;
    }
};function BlobVertex( $block, meta ) {
    var data = $block.data('blob');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        updateIweConcepts: updateIweConcepts,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_blob_block( meta, label );

    $( form ).children().appendTo( self );
    self.addClass("blob_block")
        .data('blob', self)
        .data('type', 'blob');

    return self;

    function updateIweConcepts($iweBlock) {
        /* onchange */
        var change = getIweChangeFunction($iweBlock, self, self.meta);

        self.find( 'input' ).unbind( 'change' ).change(function() {
            var value = this.value;

            if ( !value ) {
                self.addClass("error");
                return;
            }

            self.removeClass("error");

            change(value, function() {});
        });
    }

    function getInfo() {
        var value = TO.BLOB( self.find( 'input' ).val() );

        if ( !value.match( TERMINAL.VALUE.BLOB ) ) {
            self.addClass("error");
            return;
        }
        self.removeClass("error");

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = FROM.BLOB( info.sort );
        self.find( 'input' ).val( value ? value : "" );

        return self;
    }

    function get_blob_block( element_metainf, title ) {
        var blob_block = document.createElement( 'div' ),
            label = document.createElement( 'label' ),
            input = document.createElement( 'input' );

        input.value = DEFAULT_VALUE[ self.meta.sort ];

        if ( title ) {
            var ttl = document.createElement( 'span' );
            ttl.textContent = title;
            label.appendChild( ttl );
        }
        label.appendChild( input );

        blob_block.appendChild( label );

        return blob_block;
    }
};function TerminalVertex( $block, meta ) {
    var data = $block.data('terminal');
    if (data) {
        return data;
    }

    /* init object */
    var self = $.extend($block, {
        meta: meta,
        setInfo: setInfo,
        getInfo: getInfo,
        destroy: function() {
            self.html('');
        }
    });

    /* init DOM */
    var label = ( !in_array( SPECIFIER.PROXY, meta.specifiers ) ? meta.name : null );
    var form = get_terminal_block( meta, label );

    $( form ).children().appendTo( $block );
    self.addClass("terminal_block")
        .data('terminal', self)
        .data('type', 'terminal');

    return self;

    function getInfo() {
        var value = self.meta.sort;

        return new Vertex( self.meta.name, self.meta.specifiers, self.meta.interface_specifier, value );
    }

    function setInfo( info ) {
        var value = info.sort.match( TERMINAL.VALUE.REGULAR_EXPR );
        self.find( 'span' ).text( value ? value[0] : "" );

        return self;
    }

    function get_terminal_block( element_metainf, title ) {
        var terminal_block = document.createElement( 'div' ),
              value_block = document.createElement( 'span' ),
              value = element_metainf.sort.match( TERMINAL.VALUE.REGULAR_EXPR );

        value_block.textContent = ( value ? value[0] : "" );
        
        if ( title ) {
            var ttl = document.createElement( 'label' );
            ttl.textContent = title + " ";
            terminal_block.appendChild( ttl );
        }

        terminal_block.appendChild( value_block );
        
        return terminal_block;
    }
}$.fn.tableRepresentation = function(options) {
    var data = this.data('table-representation');
    if (data) {
        return data;
    }

    var settings = $.extend({
        orientation: 'HORIZONTAL'
    }, options || {});

    var _self = $( this );

    /* prepare interface */
    _self.closest('.iwe-concept').find('>div.iwe-concept-details')
    ;//.css('display', 'none');

    /* put table */
    var parser = IrParser();
    var meta = parser.toJson( _self.data('tpir-meta') );

    meta.transformToCollection( COLLECTION_ORIENTATION[ settings.orientation ] );

    _self = $.extend(AbstractVertex( _self, meta ), {
        refresh: refresh
    });

    var info;

    if ( info = _self.data('tpir-info') ) {
        _self.setInfo( parser.toJson( info ) );
    }

    initLoading(_self);

    _self.refresh();

    _self.data('table-representation', _self);

    return _self;

    function refresh($concept) {
        $concept = $concept || _self.closest('.iwe-concept');

        unfold($concept, function() {
            _self.updateIweConcepts($concept);
        });
    }

    function unfold($concept, callback) {
        $concept = $concept || _self.closest('.iwe-concept');
        var $unfolded = $concept.find('[title="' + ACTION.SHOW +'"]');

        if ($unfolded.length > 0) {
            var args = retrieveActionsArgs($unfolded);
            doPlatformActions(args, _self, function() {
                unfold($concept, callback);
            });
        } else {
            if (typeof(callback) === "function") {
                callback();
            }
        }
    }
};})( jQuery );
